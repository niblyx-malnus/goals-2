/-  p=pytz
/+  tu=time-utils
|%
++  zn
  |_  =zone:p
  ++  active-rule
    |=  time=@da
    ^-  (unit [jump:tu rule:p])
    (ram:zon:p (lot:zon:p zone ~ `time))
  ::
  ++  active-offset
    |=  time=@da
    ^-  (unit delta:tu)
    (bind (active-rule time) (cork tail head))
  :: set of all offsets in the timezone
  ::
  ++  offsets
    ^-  (set delta:tu)
    %-  ~(gas in *(set delta:tu))
    %+  turn  (tap:zon:p zone)
    (cork tail head)
  ::
  ++  utc-to-tz
    ^-  utc-to-tz:tu
    |=  time=@da
    ^-  (unit dext:tu)
    ?~  off=(active-offset time)
      ~
    =/  tz-time=@da  (apply-delta:tu time u.off)
    :: is this the first or second occurence of this tz-time?
    ::
    =/  times=(list @da)  (tz-to-utc-list tz-time)
    ?~  idx=(find [time]~ times)
      ~
    [~ u.idx tz-time]
  ::
  ++  tz-to-utc
    ^-  tz-to-utc:tu
    |=  =dext:tu
    ^-  (unit @da)
    :: generate all possible times
    ::
    =/  times=(list @da)  (tz-to-utc-list d.dext)
    :: return the time at the requested index
    ::
    ?:((lte (lent times) i.dext) ~ (some (snag i.dext times)))
  :: time ordered list of valid candidates
  ::
  ++  tz-to-utc-list
    ^-  tz-to-utc-list:tu
    |=  time=@da
    |^
    ^-  (list @da)
    (sort candidates lth)
    :: invert this time for all offsets of the timezone
    ::
    ++  candidates
      ^-  (list @da)
      %+  murn  ~(tap in offsets)
      |=  offset=delta:tu
      ^-  (unit @da)
      =/  candidate=@da  (apply-invert-delta:tu time offset)
      ?.  (validate candidate offset)
        ~
      [~ candidate]
    :: check whether a candidate could have been validly
    :: generated by the given offset
    ::
    ++  validate
      |=  [utc-time=@da offset=delta:tu]
      ^-  ?
      ?~  off=(active-offset time)
        %.n
      =(offset u.off)
    --
  --
::
++  enjs
  =,  enjs:format
  |%
  ++  zone
    |=  =zone:p
    ^-  json
    :-  %a
    %+  turn  (tap:zon:p zone)
    |=  [=jump:tu =rule:p]
    ^-  json
    %-  pairs
    :~  jump/s+(crip (en:datetime-local:tu jump))
        offset/s+(en:offset:tu offset.rule)
        name/s+name.rule
    ==
  ::
  ++  zones
    |=  =zones:p
    ^-  json
    =-  o/(malt -)
    ^-  (list [@t json])
    %+  turn  ~(tap by zones)
    |=  [k=@t v=zone:p]
    [k (zone v)]
  --
--
